/*
 * Copyright 2024 u-blox
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @file
 * @brief FreeRTOS port layer implementation
 *
 * This port provides complete UART implementations for multiple embedded platforms.
 * 
 * PLATFORM CONFIGURATION:
 * =======================
 * Define one of the following in your build system:
 * - U_PORT_STM32_HAL    : For STM32 with HAL library
 * - U_PORT_ESP32        : For ESP32/ESP-IDF
 * - U_PORT_NXP_SDK      : For NXP MCUXpresso SDK
 * - U_PORT_ATMEL_ASF    : For Microchip/Atmel ASF
 * - U_PORT_TI_DRIVERLIB : For TI DriverLib
 * - U_PORT_SILABS_GECKO : For Silicon Labs Gecko SDK
 * - U_PORT_RENESAS_FSP  : For Renesas FSP
 * - U_PORT_ARM_CORTEXA  : For ARM Cortex-A with FreeRTOS+POSIX
 * - U_PORT_RISCV        : For RISC-V with memory-mapped UART
 *
 * STM32 EXAMPLE:
 * ==============
 * 1. In your project settings, define:
 *    - U_PORT_FREERTOS
 *    - U_PORT_STM32_HAL
 *    - STM32F4 (or your STM32 family)
 *
 * 2. Make sure you have UART initialized in main.c:
 *    // Generated by STM32CubeMX
 *    UART_HandleTypeDef huart1;
 *
 * 3. In your application:
 *    #include "u_port.h"
 *    
 *    void myTask(void *pvParameters) {
 *        uCxAtClient_t client;
 *        uCxHandle_t ucxHandle;
 *        
 *        uPortAtInit(&client);
 *        if (uPortAtOpen(&client, "UART1", 115200, true)) {
 *            uCxInit(&client, &ucxHandle);
 *            // Use the API...
 *            uPortAtClose(&client);
 *        }
 *    }
 *
 * ESP32 EXAMPLE:
 * ==============
 * 1. Define: U_PORT_FREERTOS and U_PORT_ESP32
 * 2. Configure UART pins in your hardware init
 * 3. Use device name "UART0", "UART1", or "UART2"
 *
 * NXP EXAMPLE:
 * ============
 * 1. Define: U_PORT_FREERTOS and U_PORT_NXP_SDK
 * 2. Initialize clocks for UART
 * 3. Use device name "UART0", "UART1", "UART2"
 */

#include <string.h>
#include "FreeRTOS.h"
#include "semphr.h"
#include "task.h"

#include "u_cx_log.h"
#include "u_port.h"

/* ----------------------------------------------------------------
 * PLATFORM SELECTION
 * Select your platform by defining one of the following:
 * U_PORT_STM32_HAL    - STM32 using HAL library
 * U_PORT_STM32_LL     - STM32 using Low-Layer (LL) library
 * U_PORT_ESP32        - ESP32/ESP-IDF
 * U_PORT_NXP_SDK      - NXP MCUXpresso SDK (Kinetis, LPC, i.MX RT)
 * U_PORT_ATMEL_ASF    - Microchip/Atmel ASF (SAM D/E/C/S/L)
 * U_PORT_TI_DRIVERLIB - Texas Instruments DriverLib (MSP432, Tiva C)
 * U_PORT_SILABS_GECKO - Silicon Labs Gecko SDK (EFM32/EFR32)
 * U_PORT_RENESAS_FSP  - Renesas FSP (RA series)
 * U_PORT_ARM_CORTEXA  - ARM Cortex-A (with FreeRTOS+POSIX)
 * U_PORT_RISCV        - RISC-V cores (SiFive, GigaDevice, etc.)
 * -------------------------------------------------------------- */

/* Platform-specific includes */
#if defined(U_PORT_STM32_HAL)
  /* Include your STM32 HAL header based on your family */
  #if defined(STM32F0)
    #include "stm32f0xx_hal.h"
  #elif defined(STM32F1)
    #include "stm32f1xx_hal.h"
  #elif defined(STM32F2)
    #include "stm32f2xx_hal.h"
  #elif defined(STM32F3)
    #include "stm32f3xx_hal.h"
  #elif defined(STM32F4)
    #include "stm32f4xx_hal.h"
  #elif defined(STM32F7)
    #include "stm32f7xx_hal.h"
  #elif defined(STM32G0)
    #include "stm32g0xx_hal.h"
  #elif defined(STM32G4)
    #include "stm32g4xx_hal.h"
  #elif defined(STM32H7)
    #include "stm32h7xx_hal.h"
  #elif defined(STM32L0)
    #include "stm32l0xx_hal.h"
  #elif defined(STM32L1)
    #include "stm32l1xx_hal.h"
  #elif defined(STM32L4)
    #include "stm32l4xx_hal.h"
  #elif defined(STM32L5)
    #include "stm32l5xx_hal.h"
  #elif defined(STM32U5)
    #include "stm32u5xx_hal.h"
  #elif defined(STM32WB)
    #include "stm32wbxx_hal.h"
  #elif defined(STM32WL)
    #include "stm32wlxx_hal.h"
  #else
    #error "Unknown STM32 family. Please define STM32Fxx, STM32Gxx, STM32Hxx, STM32Lxx, STM32Uxx, or STM32WB/WL"
  #endif
  typedef UART_HandleTypeDef* uPortUartHandle_t;

#elif defined(U_PORT_ESP32)
  #include "driver/uart.h"
  #include "esp_log.h"
  typedef uart_port_t uPortUartHandle_t;

#elif defined(U_PORT_NXP_SDK)
  #include "fsl_uart.h"
  #include "fsl_clock.h"
  typedef UART_Type* uPortUartHandle_t;

#elif defined(U_PORT_ATMEL_ASF)
  #include "usart.h"
  typedef struct usart_module* uPortUartHandle_t;

#elif defined(U_PORT_TI_DRIVERLIB)
  #include "driverlib.h"
  typedef uint32_t uPortUartHandle_t;  // UART base address

#elif defined(U_PORT_SILABS_GECKO)
  #include "em_usart.h"
  #include "em_cmu.h"
  typedef USART_TypeDef* uPortUartHandle_t;

#elif defined(U_PORT_RENESAS_FSP)
  #include "hal_data.h"
  typedef uart_instance_t* uPortUartHandle_t;

#elif defined(U_PORT_ARM_CORTEXA)
  /* ARM Cortex-A with FreeRTOS+POSIX */
  #include <fcntl.h>
  #include <termios.h>
  #include <unistd.h>
  #include <sys/ioctl.h>
  #include <poll.h>
  typedef int uPortUartHandle_t;  // POSIX file descriptor

#elif defined(U_PORT_RISCV)
  /* RISC-V - Generic implementation using memory-mapped UART */
  /* Common for SiFive FE310, GD32VF103, Nuclei, etc. */
  #include <stdint.h>
  
  /* UART register structure (standard 16550-compatible or platform-specific) */
  typedef struct {
      volatile uint32_t data;      /* Data register */
      volatile uint32_t status;    /* Status register */
      volatile uint32_t control;   /* Control register */
      volatile uint32_t baud;      /* Baud rate divisor */
  } riscv_uart_regs_t;
  
  typedef riscv_uart_regs_t* uPortUartHandle_t;
  
  /* Define UART base addresses for your platform */
  #ifndef RISCV_UART0_BASE
    #define RISCV_UART0_BASE 0x10013000  /* SiFive FE310 default */
  #endif
  #ifndef RISCV_UART1_BASE
    #define RISCV_UART1_BASE 0x10023000
  #endif

#else
  /* Generic/Custom platform */
  typedef void* uPortUartHandle_t;
  #warning "No platform defined. UART functions will return placeholder values."
  #warning "Define U_PORT_STM32_HAL, U_PORT_ESP32, U_PORT_ARM_CORTEXA, U_PORT_RISCV, or another supported platform."
#endif

/* ----------------------------------------------------------------
 * COMPILE-TIME MACROS
 * -------------------------------------------------------------- */

/* ----------------------------------------------------------------
 * TYPES
 * -------------------------------------------------------------- */

/* ----------------------------------------------------------------
 * TYPES
 * -------------------------------------------------------------- */

typedef struct {
    uPortUartHandle_t pUartHandle;  // Platform-specific UART handle
    uCxAtClient_t *pClient;
} uPortContext_t;

/* ----------------------------------------------------------------
 * UART INSTANCE MAPPING
 * Define external UART handles for your platform
 * These should be defined in your main.c or hardware init code
 * -------------------------------------------------------------- */

#if defined(U_PORT_STM32_HAL)
  /* For STM32 HAL, declare your UART handles as extern */
  /* These are typically created by STM32CubeMX */
  extern UART_HandleTypeDef huart1;
  extern UART_HandleTypeDef huart2;
  extern UART_HandleTypeDef huart3;
  /* Add more as needed for your application */

#elif defined(U_PORT_ESP32)
  /* ESP32 uses numeric UART ports */
  #define UART_NUM_0 0
  #define UART_NUM_1 1
  #define UART_NUM_2 2

#elif defined(U_PORT_NXP_SDK)
  /* NXP SDK uses UART base addresses */
  /* These are typically defined in the device header */

#elif defined(U_PORT_ATMEL_ASF)
  /* Atmel ASF - declare your USART instances */
  extern struct usart_module usart_instance;

#elif defined(U_PORT_TI_DRIVERLIB)
  /* TI DriverLib - UART base addresses from device header */

#elif defined(U_PORT_SILABS_GECKO)
  /* Silicon Labs - declare your USART instances */
  /* USART0, USART1, etc. are defined in device headers */

#elif defined(U_PORT_RENESAS_FSP)
  /* Renesas FSP - declare your UART instances */
  extern const uart_instance_t g_uart0;

#elif defined(U_PORT_ARM_CORTEXA)
  /* ARM Cortex-A uses POSIX device names */
  /* e.g., "/dev/ttyS0", "/dev/ttyAMA0", "/dev/ttyUSB0" */

#elif defined(U_PORT_RISCV)
  /* RISC-V UART base addresses */
  /* Adjust these for your specific RISC-V SoC */
  #define UART0_REGS ((riscv_uart_regs_t*)RISCV_UART0_BASE)
  #define UART1_REGS ((riscv_uart_regs_t*)RISCV_UART1_BASE)
  
  /* Status register bit definitions (platform-specific) */
  #ifndef UART_STATUS_RXNE
    #define UART_STATUS_RXNE (1 << 0)  /* RX not empty */
  #endif
  #ifndef UART_STATUS_TXE
    #define UART_STATUS_TXE  (1 << 1)  /* TX empty */
  #endif
#endif

/* ----------------------------------------------------------------
 * STATIC PROTOTYPES
 * -------------------------------------------------------------- */

static int32_t uartWrite(uCxAtClient_t *pClient, void *pStreamHandle, const void *pData, size_t length);
static int32_t uartRead(uCxAtClient_t *pClient, void *pStreamHandle, void *pData, size_t length, int32_t timeoutMs);

/* ----------------------------------------------------------------
 * STATIC VARIABLES
 * -------------------------------------------------------------- */

static uCxAtClientConfig_t *gPConfig = NULL;

/* ----------------------------------------------------------------
 * HARDWARE-SPECIFIC UART FUNCTIONS
 * -------------------------------------------------------------- */

/**
 * Open and configure UART for the specified device
 * 
 * @param[in] pDevName:        Device name (e.g., "UART1", "UART2")
 * @param[in] baudRate:        UART baud rate
 * @param[in] useFlowControl:  Enable CTS/RTS flow control
 * @return Pointer to UART handle on success, NULL on failure
 */
static uPortUartHandle_t uPortUartOpen(const char *pDevName, int baudRate, bool useFlowControl)
{
#if defined(U_PORT_STM32_HAL)
    /* ===== STM32 HAL Implementation ===== */
    UART_HandleTypeDef *pHuart = NULL;
    
    /* Map device name to UART handle */
    if (strcmp(pDevName, "UART1") == 0 || strcmp(pDevName, "USART1") == 0) {
        pHuart = &huart1;
    } else if (strcmp(pDevName, "UART2") == 0 || strcmp(pDevName, "USART2") == 0) {
        pHuart = &huart2;
    } else if (strcmp(pDevName, "UART3") == 0 || strcmp(pDevName, "USART3") == 0) {
        pHuart = &huart3;
    } else {
        return NULL;  // Unknown UART
    }
    
    /* Configure UART parameters */
    pHuart->Init.BaudRate = baudRate;
    pHuart->Init.WordLength = UART_WORDLENGTH_8B;
    pHuart->Init.StopBits = UART_STOPBITS_1;
    pHuart->Init.Parity = UART_PARITY_NONE;
    pHuart->Init.Mode = UART_MODE_TX_RX;
    
    if (useFlowControl) {
        pHuart->Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
    } else {
        pHuart->Init.HwFlowCtl = UART_HWCONTROL_NONE;
    }
    
    pHuart->Init.OverSampling = UART_OVERSAMPLING_16;
    
    /* Initialize UART */
    if (HAL_UART_Init(pHuart) != HAL_OK) {
        return NULL;
    }
    
    return pHuart;

#elif defined(U_PORT_ESP32)
    /* ===== ESP32 Implementation ===== */
    uart_port_t uart_num;
    
    /* Map device name to UART port */
    if (strcmp(pDevName, "UART0") == 0) {
        uart_num = UART_NUM_0;
    } else if (strcmp(pDevName, "UART1") == 0) {
        uart_num = UART_NUM_1;
    } else if (strcmp(pDevName, "UART2") == 0) {
        uart_num = UART_NUM_2;
    } else {
        return (uPortUartHandle_t)-1;
    }
    
    /* Configure UART parameters */
    uart_config_t uart_config = {
        .baud_rate = baudRate,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = useFlowControl ? UART_HW_FLOWCTRL_CTS_RTS : UART_HW_FLOWCTRL_DISABLE,
        .rx_flow_ctrl_thresh = 122,
    };
    
    /* Install UART driver */
    if (uart_param_config(uart_num, &uart_config) != ESP_OK) {
        return (uPortUartHandle_t)-1;
    }
    
    /* Note: You may need to configure pins and install driver */
    /* uart_set_pin(uart_num, TX_PIN, RX_PIN, RTS_PIN, CTS_PIN); */
    /* uart_driver_install(uart_num, RX_BUF_SIZE, TX_BUF_SIZE, 0, NULL, 0); */
    
    return uart_num;

#elif defined(U_PORT_NXP_SDK)
    /* ===== NXP MCUXpresso SDK Implementation ===== */
    UART_Type *base = NULL;
    
    /* Map device name to UART base */
    if (strcmp(pDevName, "UART0") == 0) {
        base = UART0;
    } else if (strcmp(pDevName, "UART1") == 0) {
        base = UART1;
    } else if (strcmp(pDevName, "UART2") == 0) {
        base = UART2;
    } else {
        return NULL;
    }
    
    /* Configure UART */
    uart_config_t config;
    UART_GetDefaultConfig(&config);
    config.baudRate_Bps = baudRate;
    config.enableTx = true;
    config.enableRx = true;
    
    if (useFlowControl) {
        config.enableRxRTS = true;
        config.enableTxCTS = true;
    }
    
    /* Get clock frequency - adjust for your platform */
    uint32_t srcClock = CLOCK_GetFreq(kCLOCK_CoreSysClk);
    
    if (UART_Init(base, &config, srcClock) != kStatus_Success) {
        return NULL;
    }
    
    return base;

#elif defined(U_PORT_ATMEL_ASF)
    /* ===== Microchip/Atmel ASF Implementation ===== */
    struct usart_module *usart_inst = &usart_instance;
    
    struct usart_config config_usart;
    usart_get_config_defaults(&config_usart);
    
    config_usart.baudrate = baudRate;
    config_usart.mux_setting = USART_RX_1_TX_2_XCK_3;  // Adjust for your board
    config_usart.pinmux_pad0 = PINMUX_UNUSED;
    config_usart.pinmux_pad1 = PINMUX_PA11C_SERCOM0_PAD1;  // RX - adjust
    config_usart.pinmux_pad2 = PINMUX_PA10C_SERCOM0_PAD2;  // TX - adjust
    config_usart.pinmux_pad3 = PINMUX_UNUSED;
    
    if (useFlowControl) {
        /* Configure RTS/CTS pins if needed */
    }
    
    /* Initialize USART */
    if (usart_init(usart_inst, SERCOM0, &config_usart) != STATUS_OK) {
        return NULL;
    }
    
    usart_enable(usart_inst);
    
    return usart_inst;

#elif defined(U_PORT_TI_DRIVERLIB)
    /* ===== Texas Instruments DriverLib Implementation ===== */
    uint32_t uart_base;
    
    /* Map device name to UART base address */
    if (strcmp(pDevName, "UART0") == 0) {
        uart_base = EUSCI_A0_BASE;  // MSP432
    } else if (strcmp(pDevName, "UART1") == 0) {
        uart_base = EUSCI_A1_BASE;
    } else {
        return 0;
    }
    
    /* Configure UART */
    eUSCI_UART_ConfigV1 uartConfig = {
        EUSCI_A_UART_CLOCKSOURCE_SMCLK,
        0,  // Will be calculated
        0,
        0,
        EUSCI_A_UART_NO_PARITY,
        EUSCI_A_UART_LSB_FIRST,
        EUSCI_A_UART_ONE_STOP_BIT,
        EUSCI_A_UART_MODE,
        EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION,
        useFlowControl ? EUSCI_A_UART_AUTOMATIC_FLOWCONTROL_MODE : EUSCI_A_UART_FLOWCONTROL_NONE
    };
    
    /* Calculate baud rate divisors - adjust clock source as needed */
    uint32_t clockFreq = 12000000;  // 12 MHz SMCLK - adjust for your system
    uartConfig.clockPrescalar = clockFreq / (16 * baudRate);
    uartConfig.firstModReg = ((clockFreq / baudRate) % 16);
    
    /* Initialize UART */
    MAP_UART_initModule(uart_base, &uartConfig);
    MAP_UART_enableModule(uart_base);
    
    return uart_base;

#elif defined(U_PORT_SILABS_GECKO)
    /* ===== Silicon Labs Gecko SDK Implementation ===== */
    USART_TypeDef *usart = NULL;
    
    /* Map device name to USART */
    if (strcmp(pDevName, "USART0") == 0) {
        usart = USART0;
        CMU_ClockEnable(cmuClock_USART0, true);
    } else if (strcmp(pDevName, "USART1") == 0) {
        usart = USART1;
        CMU_ClockEnable(cmuClock_USART1, true);
    } else {
        return NULL;
    }
    
    /* Configure USART */
    USART_InitAsync_TypeDef init = USART_INITASYNC_DEFAULT;
    init.baudrate = baudRate;
    init.hwFlowControl = useFlowControl ? usartHwFlowControlCtsAndRts : usartHwFlowControlNone;
    
    /* Initialize USART */
    USART_InitAsync(usart, &init);
    
    /* Configure GPIO pins - adjust for your board */
    /* GPIO_PinModeSet(...); */
    
    return usart;

#elif defined(U_PORT_RENESAS_FSP)
    /* ===== Renesas FSP Implementation ===== */
    uart_instance_t *p_uart = (uart_instance_t*)&g_uart0;
    
    /* Open UART */
    if (p_uart->p_api->open(p_uart->p_ctrl, p_uart->p_cfg) != FSP_SUCCESS) {
        return NULL;
    }
    
    /* Note: Baud rate and flow control are typically configured in FSP configurator */
    /* You may need to modify the configuration structure if dynamic changes are needed */
    
    return p_uart;

#elif defined(U_PORT_ARM_CORTEXA)
    /* ===== ARM Cortex-A with FreeRTOS+POSIX Implementation ===== */
    int fd;
    struct termios options;
    
    /* Open the serial port */
    fd = open(pDevName, O_RDWR | O_NOCTTY | O_NDELAY);
    if (fd == -1) {
        return -1;
    }
    
    /* Configure port to be non-blocking */
    fcntl(fd, F_SETFL, 0);
    
    /* Get current options */
    tcgetattr(fd, &options);
    
    /* Set baud rate */
    speed_t speed;
    switch (baudRate) {
        case 9600:   speed = B9600;   break;
        case 19200:  speed = B19200;  break;
        case 38400:  speed = B38400;  break;
        case 57600:  speed = B57600;  break;
        case 115200: speed = B115200; break;
        case 230400: speed = B230400; break;
        case 460800: speed = B460800; break;
        case 921600: speed = B921600; break;
        default:     speed = B115200; break;
    }
    cfsetispeed(&options, speed);
    cfsetospeed(&options, speed);
    
    /* 8N1 mode */
    options.c_cflag &= ~PARENB;  /* No parity */
    options.c_cflag &= ~CSTOPB;  /* 1 stop bit */
    options.c_cflag &= ~CSIZE;
    options.c_cflag |= CS8;      /* 8 data bits */
    
    /* Hardware flow control */
    if (useFlowControl) {
        options.c_cflag |= CRTSCTS;
    } else {
        options.c_cflag &= ~CRTSCTS;
    }
    
    /* Enable receiver, ignore modem control lines */
    options.c_cflag |= (CLOCAL | CREAD);
    
    /* Raw input */
    options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
    
    /* Raw output */
    options.c_oflag &= ~OPOST;
    
    /* Set input modes */
    options.c_iflag &= ~(IXON | IXOFF | IXANY);  /* No software flow control */
    options.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL);
    
    /* Apply options */
    tcsetattr(fd, TCSANOW, &options);
    
    /* Flush any existing data */
    tcflush(fd, TCIOFLUSH);
    
    return fd;

#elif defined(U_PORT_RISCV)
    /* ===== RISC-V Memory-Mapped UART Implementation ===== */
    riscv_uart_regs_t *uart = NULL;
    
    /* Map device name to UART instance */
    if (strcmp(pDevName, "UART0") == 0) {
        uart = UART0_REGS;
    } else if (strcmp(pDevName, "UART1") == 0) {
        uart = UART1_REGS;
    } else {
        return NULL;
    }
    
    /* Calculate baud rate divisor */
    /* Assuming 32 MHz clock - adjust for your RISC-V SoC */
    #ifndef RISCV_CLOCK_FREQ
      #define RISCV_CLOCK_FREQ 32000000
    #endif
    
    uint32_t divisor = RISCV_CLOCK_FREQ / baudRate;
    uart->baud = divisor;
    
    /* Configure control register */
    /* Typical format: enable TX, enable RX, 8 data bits, 1 stop bit, no parity */
    uint32_t ctrl = 0;
    ctrl |= (1 << 0);  /* Enable UART */
    ctrl |= (1 << 1);  /* Enable TX */
    ctrl |= (1 << 2);  /* Enable RX */
    
    if (useFlowControl) {
        ctrl |= (1 << 3);  /* Enable hardware flow control (if supported) */
    }
    
    uart->control = ctrl;
    
    /* Clear any pending data */
    while (uart->status & UART_STATUS_RXNE) {
        (void)uart->data;  /* Read and discard */
    }
    
    return uart;

#else
    /* ===== Generic/Placeholder Implementation ===== */
    (void)pDevName;
    (void)baudRate;
    (void)useFlowControl;
    
    U_CX_LOG_LINE(U_CX_LOG_CH_ERROR, "uPortUartOpen() not implemented for your platform!");
    U_CX_LOG_LINE(U_CX_LOG_CH_ERROR, "Define U_PORT_STM32_HAL, U_PORT_ESP32, U_PORT_ARM_CORTEXA, U_PORT_RISCV, or another supported platform.");
    
    return NULL;
#endif
}

/**
 * Close UART
 * 
 * @param[in] pUartHandle:  Handle returned by uPortUartOpen()
 */
static void uPortUartClose(uPortUartHandle_t pUartHandle)
{
#if defined(U_PORT_STM32_HAL)
    UART_HandleTypeDef *pHuart = (UART_HandleTypeDef *)pUartHandle;
    HAL_UART_DeInit(pHuart);

#elif defined(U_PORT_ESP32)
    uart_port_t uart_num = (uart_port_t)pUartHandle;
    uart_driver_delete(uart_num);

#elif defined(U_PORT_NXP_SDK)
    UART_Type *base = (UART_Type *)pUartHandle;
    UART_Deinit(base);

#elif defined(U_PORT_ATMEL_ASF)
    struct usart_module *usart_inst = (struct usart_module *)pUartHandle;
    usart_disable(usart_inst);

#elif defined(U_PORT_TI_DRIVERLIB)
    uint32_t uart_base = (uint32_t)pUartHandle;
    MAP_UART_disableModule(uart_base);

#elif defined(U_PORT_SILABS_GECKO)
    USART_TypeDef *usart = (USART_TypeDef *)pUartHandle;
    USART_Enable(usart, usartDisable);

#elif defined(U_PORT_RENESAS_FSP)
    uart_instance_t *p_uart = (uart_instance_t *)pUartHandle;
    p_uart->p_api->close(p_uart->p_ctrl);

#elif defined(U_PORT_ARM_CORTEXA)
    int fd = (int)pUartHandle;
    if (fd >= 0) {
        close(fd);
    }

#elif defined(U_PORT_RISCV)
    riscv_uart_regs_t *uart = (riscv_uart_regs_t *)pUartHandle;
    if (uart != NULL) {
        /* Disable UART */
        uart->control = 0;
    }

#else
    (void)pUartHandle;
#endif
}

/**
 * Write data to UART
 * 
 * @param[in] pUartHandle:  Handle returned by uPortUartOpen()
 * @param[in] pData:        Data to write
 * @param[in] length:       Number of bytes to write
 * @return Number of bytes written, or negative on error
 */
static int32_t uPortUartWrite(uPortUartHandle_t pUartHandle, const void *pData, size_t length)
{
#if defined(U_PORT_STM32_HAL)
    UART_HandleTypeDef *pHuart = (UART_HandleTypeDef *)pUartHandle;
    
    if (HAL_UART_Transmit(pHuart, (uint8_t *)pData, length, 1000) == HAL_OK) {
        return (int32_t)length;
    }
    return -1;

#elif defined(U_PORT_ESP32)
    uart_port_t uart_num = (uart_port_t)pUartHandle;
    int written = uart_write_bytes(uart_num, (const char *)pData, length);
    return written;

#elif defined(U_PORT_NXP_SDK)
    UART_Type *base = (UART_Type *)pUartHandle;
    UART_WriteBlocking(base, (const uint8_t *)pData, length);
    return (int32_t)length;

#elif defined(U_PORT_ATMEL_ASF)
    struct usart_module *usart_inst = (struct usart_module *)pUartHandle;
    const uint8_t *p = (const uint8_t *)pData;
    
    for (size_t i = 0; i < length; i++) {
        if (usart_write_wait(usart_inst, p[i]) != STATUS_OK) {
            return (int32_t)i;
        }
    }
    return (int32_t)length;

#elif defined(U_PORT_TI_DRIVERLIB)
    uint32_t uart_base = (uint32_t)pUartHandle;
    const uint8_t *p = (const uint8_t *)pData;
    
    for (size_t i = 0; i < length; i++) {
        MAP_UART_transmitData(uart_base, p[i]);
    }
    return (int32_t)length;

#elif defined(U_PORT_SILABS_GECKO)
    USART_TypeDef *usart = (USART_TypeDef *)pUartHandle;
    const uint8_t *p = (const uint8_t *)pData;
    
    for (size_t i = 0; i < length; i++) {
        USART_Tx(usart, p[i]);
    }
    return (int32_t)length;

#elif defined(U_PORT_RENESAS_FSP)
    uart_instance_t *p_uart = (uart_instance_t *)pUartHandle;
    
    if (p_uart->p_api->write(p_uart->p_ctrl, (uint8_t *)pData, length) == FSP_SUCCESS) {
        return (int32_t)length;
    }
    return -1;

#elif defined(U_PORT_ARM_CORTEXA)
    int fd = (int)pUartHandle;
    ssize_t written = write(fd, pData, length);
    return (int32_t)written;

#elif defined(U_PORT_RISCV)
    riscv_uart_regs_t *uart = (riscv_uart_regs_t *)pUartHandle;
    const uint8_t *p = (const uint8_t *)pData;
    
    for (size_t i = 0; i < length; i++) {
        /* Wait for TX ready */
        while ((uart->status & UART_STATUS_TXE) == 0) {
            /* Busy wait */
        }
        uart->data = p[i];
    }
    return (int32_t)length;

#else
    (void)pUartHandle;
    (void)pData;
    (void)length;
    return -1;
#endif
}

/**
 * Read data from UART
 * 
 * @param[in]  pUartHandle:  Handle returned by uPortUartOpen()
 * @param[out] pData:        Buffer to read into
 * @param[in]  length:       Maximum bytes to read
 * @param[in]  timeoutMs:    Timeout in milliseconds (0 = non-blocking)
 * @return Number of bytes read, 0 if no data available, or negative on error
 */
static int32_t uPortUartRead(uPortUartHandle_t pUartHandle, void *pData, size_t length, int32_t timeoutMs)
{
#if defined(U_PORT_STM32_HAL)
    UART_HandleTypeDef *pHuart = (UART_HandleTypeDef *)pUartHandle;
    
    if (timeoutMs == 0) {
        /* Non-blocking read - check if data is available */
        if (__HAL_UART_GET_FLAG(pHuart, UART_FLAG_RXNE) == RESET) {
            return 0;  // No data available
        }
        timeoutMs = 1;  // Use minimal timeout for single byte
    }
    
    /* Try to read one byte with specified timeout */
    HAL_StatusTypeDef status = HAL_UART_Receive(pHuart, (uint8_t *)pData, 1, timeoutMs);
    
    if (status == HAL_OK) {
        return 1;  // Successfully read 1 byte
    } else if (status == HAL_TIMEOUT) {
        return 0;  // Timeout - no data
    }
    return -1;  // Error

#elif defined(U_PORT_ESP32)
    uart_port_t uart_num = (uart_port_t)pUartHandle;
    
    if (timeoutMs == 0) {
        /* Non-blocking */
        size_t available = 0;
        uart_get_buffered_data_len(uart_num, &available);
        if (available == 0) {
            return 0;
        }
        timeoutMs = 0;  // Still use non-blocking read
    }
    
    TickType_t ticks = (timeoutMs == 0) ? 0 : pdMS_TO_TICKS(timeoutMs);
    int len = uart_read_bytes(uart_num, (uint8_t *)pData, 1, ticks);
    
    return (len > 0) ? len : 0;

#elif defined(U_PORT_NXP_SDK)
    UART_Type *base = (UART_Type *)pUartHandle;
    
    if (timeoutMs == 0) {
        /* Non-blocking read */
        if ((UART_GetStatusFlags(base) & kUART_RxDataRegFullFlag) == 0) {
            return 0;  // No data available
        }
    }
    
    /* Blocking read with timeout */
    uint8_t *pByte = (uint8_t *)pData;
    uint32_t startTick = xTaskGetTickCount();
    uint32_t timeoutTicks = pdMS_TO_TICKS(timeoutMs);
    
    while ((UART_GetStatusFlags(base) & kUART_RxDataRegFullFlag) == 0) {
        if (timeoutMs > 0 && (xTaskGetTickCount() - startTick) >= timeoutTicks) {
            return 0;  // Timeout
        }
        vTaskDelay(1);
    }
    
    *pByte = UART_ReadByte(base);
    return 1;

#elif defined(U_PORT_ATMEL_ASF)
    struct usart_module *usart_inst = (struct usart_module *)pUartHandle;
    uint16_t data;
    
    if (timeoutMs == 0) {
        /* Non-blocking */
        if (usart_read_wait(usart_inst, &data) == STATUS_OK) {
            *((uint8_t *)pData) = (uint8_t)data;
            return 1;
        }
        return 0;
    }
    
    /* Blocking with timeout */
    uint32_t startTick = xTaskGetTickCount();
    uint32_t timeoutTicks = pdMS_TO_TICKS(timeoutMs);
    
    while (usart_read_wait(usart_inst, &data) != STATUS_OK) {
        if ((xTaskGetTickCount() - startTick) >= timeoutTicks) {
            return 0;  // Timeout
        }
        vTaskDelay(1);
    }
    
    *((uint8_t *)pData) = (uint8_t)data;
    return 1;

#elif defined(U_PORT_TI_DRIVERLIB)
    uint32_t uart_base = (uint32_t)pUartHandle;
    
    if (timeoutMs == 0) {
        /* Non-blocking */
        if (MAP_UART_getInterruptStatus(uart_base, EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG) == 0) {
            return 0;
        }
    }
    
    /* Blocking with timeout */
    uint32_t startTick = xTaskGetTickCount();
    uint32_t timeoutTicks = pdMS_TO_TICKS(timeoutMs);
    
    while (MAP_UART_getInterruptStatus(uart_base, EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG) == 0) {
        if (timeoutMs > 0 && (xTaskGetTickCount() - startTick) >= timeoutTicks) {
            return 0;  // Timeout
        }
        vTaskDelay(1);
    }
    
    *((uint8_t *)pData) = MAP_UART_receiveData(uart_base);
    return 1;

#elif defined(U_PORT_SILABS_GECKO)
    USART_TypeDef *usart = (USART_TypeDef *)pUartHandle;
    
    if (timeoutMs == 0) {
        /* Non-blocking */
        if ((usart->STATUS & USART_STATUS_RXDATAV) == 0) {
            return 0;
        }
        *((uint8_t *)pData) = USART_Rx(usart);
        return 1;
    }
    
    /* Blocking with timeout */
    uint32_t startTick = xTaskGetTickCount();
    uint32_t timeoutTicks = pdMS_TO_TICKS(timeoutMs);
    
    while ((usart->STATUS & USART_STATUS_RXDATAV) == 0) {
        if ((xTaskGetTickCount() - startTick) >= timeoutTicks) {
            return 0;  // Timeout
        }
        vTaskDelay(1);
    }
    
    *((uint8_t *)pData) = USART_Rx(usart);
    return 1;

#elif defined(U_PORT_RENESAS_FSP)
    uart_instance_t *p_uart = (uart_instance_t *)pUartHandle;
    
    /* Renesas FSP typically uses callback-based reception */
    /* This is a simplified polling implementation */
    if (p_uart->p_api->read(p_uart->p_ctrl, (uint8_t *)pData, 1) == FSP_SUCCESS) {
        /* Wait for completion with timeout */
        uint32_t startTick = xTaskGetTickCount();
        uint32_t timeoutTicks = pdMS_TO_TICKS(timeoutMs > 0 ? timeoutMs : 1);
        
        while ((xTaskGetTickCount() - startTick) < timeoutTicks) {
            /* Check if read completed - implementation depends on FSP configuration */
            vTaskDelay(1);
        }
        return 1;
    }
    return 0;

#elif defined(U_PORT_ARM_CORTEXA)
    int fd = (int)pUartHandle;
    
    if (timeoutMs == 0) {
        /* Non-blocking read */
        /* Check if data is available without blocking */
        int bytes_avail = 0;
        ioctl(fd, FIONREAD, &bytes_avail);
        if (bytes_avail == 0) {
            return 0;
        }
        
        ssize_t n = read(fd, pData, 1);
        return (n > 0) ? (int32_t)n : 0;
    }
    
    /* Blocking read with timeout using poll() */
    struct pollfd fds;
    fds.fd = fd;
    fds.events = POLLIN;
    
    int poll_result = poll(&fds, 1, timeoutMs);
    if (poll_result > 0 && (fds.revents & POLLIN)) {
        ssize_t n = read(fd, pData, 1);
        return (n > 0) ? (int32_t)n : 0;
    }
    return 0;  // Timeout or no data

#elif defined(U_PORT_RISCV)
    riscv_uart_regs_t *uart = (riscv_uart_regs_t *)pUartHandle;
    uint8_t *pByte = (uint8_t *)pData;
    
    if (timeoutMs == 0) {
        /* Non-blocking */
        if (uart->status & UART_STATUS_RXNE) {
            *pByte = uart->data;
            return 1;
        }
        return 0;
    }
    
    /* Blocking with timeout */
    uint32_t startTick = xTaskGetTickCount();
    uint32_t timeoutTicks = pdMS_TO_TICKS(timeoutMs);
    
    while ((uart->status & UART_STATUS_RXNE) == 0) {
        if ((xTaskGetTickCount() - startTick) >= timeoutTicks) {
            return 0;  // Timeout
        }
        vTaskDelay(1);
    }
    
    *pByte = uart->data;
    return 1;

#else
    (void)pUartHandle;
    (void)pData;
    (void)length;
    (void)timeoutMs;
    return 0;  // No data
#endif
}

/**
 * Flush UART buffers
 * 
 * @param[in] pUartHandle:  Handle returned by uPortUartOpen()
 */
static void uPortUartFlush(uPortUartHandle_t pUartHandle)
{
#if defined(U_PORT_STM32_HAL)
    UART_HandleTypeDef *pHuart = (UART_HandleTypeDef *)pUartHandle;
    
    /* Abort any ongoing transfers */
    HAL_UART_AbortReceive(pHuart);
    HAL_UART_AbortTransmit(pHuart);
    
    /* Clear receive buffer by reading until empty */
    while (__HAL_UART_GET_FLAG(pHuart, UART_FLAG_RXNE)) {
        (void)pHuart->Instance->RDR;  // Read and discard
    }

#elif defined(U_PORT_ESP32)
    uart_port_t uart_num = (uart_port_t)pUartHandle;
    uart_flush(uart_num);
    uart_flush_input(uart_num);

#elif defined(U_PORT_NXP_SDK)
    UART_Type *base = (UART_Type *)pUartHandle;
    
    /* Clear RX FIFO */
    while (UART_GetStatusFlags(base) & kUART_RxDataRegFullFlag) {
        (void)UART_ReadByte(base);
    }

#elif defined(U_PORT_ATMEL_ASF)
    struct usart_module *usart_inst = (struct usart_module *)pUartHandle;
    
    /* Flush RX buffer */
    uint16_t dummy;
    while (usart_read_wait(usart_inst, &dummy) == STATUS_OK) {
        /* Discard data */
    }

#elif defined(U_PORT_TI_DRIVERLIB)
    uint32_t uart_base = (uint32_t)pUartHandle;
    
    /* Clear RX buffer */
    while (MAP_UART_getInterruptStatus(uart_base, EUSCI_A_UART_RECEIVE_INTERRUPT_FLAG)) {
        (void)MAP_UART_receiveData(uart_base);
    }

#elif defined(U_PORT_SILABS_GECKO)
    USART_TypeDef *usart = (USART_TypeDef *)pUartHandle;
    
    /* Clear RX buffer */
    while (usart->STATUS & USART_STATUS_RXDATAV) {
        (void)USART_Rx(usart);
    }

#elif defined(U_PORT_RENESAS_FSP)
    uart_instance_t *p_uart = (uart_instance_t *)pUartHandle;
    
    /* Abort any ongoing operations */
    p_uart->p_api->communicationAbort(p_uart->p_ctrl, UART_DIR_RX_TX);

#elif defined(U_PORT_ARM_CORTEXA)
    int fd = (int)pUartHandle;
    
    /* Flush both input and output buffers */
    tcflush(fd, TCIOFLUSH);

#elif defined(U_PORT_RISCV)
    riscv_uart_regs_t *uart = (riscv_uart_regs_t *)pUartHandle;
    
    /* Clear RX buffer by reading all pending data */
    while (uart->status & UART_STATUS_RXNE) {
        (void)uart->data;  /* Read and discard */
    }

#else
    (void)pUartHandle;
#endif
}

/* ----------------------------------------------------------------
 * STATIC FUNCTIONS
 * -------------------------------------------------------------- */

static int32_t uartWrite(uCxAtClient_t *pClient, void *pStreamHandle, const void *pData, size_t length)
{
    (void)pClient;
    uPortContext_t *pCtx = (uPortContext_t *)pStreamHandle;
    
    return uPortUartWrite(pCtx->pUartHandle, pData, length);
}

static int32_t uartRead(uCxAtClient_t *pClient, void *pStreamHandle, void *pData, size_t length, int32_t timeoutMs)
{
    (void)pClient;
    uPortContext_t *pCtx = (uPortContext_t *)pStreamHandle;
    
    return uPortUartRead(pCtx->pUartHandle, pData, length, timeoutMs);
}

/* ----------------------------------------------------------------
 * PUBLIC FUNCTIONS
 * -------------------------------------------------------------- */

int32_t uPortGetTickTimeMs(void)
{
    TickType_t ticks = xTaskGetTickCount();
    return (int32_t)(ticks * portTICK_PERIOD_MS);
}

int32_t uPortMutexTryLock(SemaphoreHandle_t mutex, int32_t timeoutMs)
{
    TickType_t ticksToWait;
    
    if (timeoutMs == 0) {
        ticksToWait = 0;
    } else if (timeoutMs < 0) {
        ticksToWait = portMAX_DELAY;
    } else {
        ticksToWait = pdMS_TO_TICKS(timeoutMs);
    }
    
    if (xSemaphoreTake(mutex, ticksToWait) == pdTRUE) {
        return 0;  // Success
    }
    return -1;  // Timeout
}

void uPortAtInit(uCxAtClient_t *pClient)
{
    static uPortContext_t context;
    static char rxBuf[1024];
#if U_CX_USE_URC_QUEUE == 1
    static char urcBuf[1024];
#endif
    static uCxAtClientConfig_t config = {
        .pRxBuffer = &rxBuf[0],
        .rxBufferLen = sizeof(rxBuf),
#if U_CX_USE_URC_QUEUE == 1
        .pUrcBuffer = &urcBuf[0],
        .urcBufferLen = sizeof(urcBuf),
#endif
        .pStreamHandle = &context,
        .write = uartWrite,
        .read = uartRead
    };

    memset(&context, 0, sizeof(context));
    context.pClient = pClient;
    context.pUartHandle = NULL;

    // Current implementation of this port only supports one instance
    configASSERT(gPConfig == NULL);
    gPConfig = &config;

    uCxAtClientInit(&config, pClient);
}

bool uPortAtOpen(uCxAtClient_t *pClient, const char *pDevName, int baudRate, bool useFlowControl)
{
    uPortContext_t *pCtx = pClient->pConfig->pStreamHandle;
    configASSERT(pClient->pConfig != NULL);
    configASSERT(pCtx != NULL);
    configASSERT(pCtx->pUartHandle == NULL);

    U_CX_LOG_LINE_I(U_CX_LOG_CH_DBG, pClient->instance, "Opening %s at %d with %s flow control",
                    pDevName, baudRate, useFlowControl ? "CTS/RTS" : "no");

    pCtx->pUartHandle = uPortUartOpen(pDevName, baudRate, useFlowControl);
    if (pCtx->pUartHandle == NULL) {
        U_CX_LOG_LINE_I(U_CX_LOG_CH_ERROR, pClient->instance, "Failed to open UART");
        return false;
    }

    return true;
}

void uPortAtClose(uCxAtClient_t *pClient)
{
    uPortContext_t *pCtx = pClient->pConfig->pStreamHandle;
    configASSERT(pCtx->pUartHandle != NULL);

    U_CX_LOG_LINE_I(U_CX_LOG_CH_DBG, pClient->instance, "Closing UART");

    uPortUartClose(pCtx->pUartHandle);
    pCtx->pUartHandle = NULL;
}

void uPortAtPauseRx(uCxAtClient_t *pClient)
{
    // No-op for FreeRTOS implementation (polling-based).
    // This port doesn't use a background RX task - the application calls
    // uCxAtClientHandleRx() explicitly, so it already has control over when
    // AT command processing happens. Raw binary protocols like XMODEM work
    // naturally without needing to pause anything.
    //
    // NOTE: If your FreeRTOS application DOES use a separate RX task that
    // calls uCxAtClientHandleRx() in the background, you should implement
    // pause/resume similar to the Windows/POSIX ports by using vTaskSuspend()
    // and vTaskResume() or by deleting and recreating the task.
    (void)pClient;
}

void uPortAtResumeRx(uCxAtClient_t *pClient)
{
    // No-op for FreeRTOS implementation (polling-based).
    // See note in uPortAtPauseRx() above.
    (void)pClient;
}

void uPortAtFlush(uCxAtClient_t *pClient)
{
    uPortContext_t *pCtx = pClient->pConfig->pStreamHandle;
    
    if (pCtx->pUartHandle != NULL) {
        // Flush hardware UART buffers
        uPortUartFlush(pCtx->pUartHandle);
        
        // Clear the AT client's internal RX buffer
        if (pClient->pConfig->pRxBuffer != NULL) {
            memset(pClient->pConfig->pRxBuffer, 0, pClient->pConfig->rxBufferLen);
        }
        
        U_CX_LOG_LINE_I(U_CX_LOG_CH_DBG, pClient->instance, "Serial buffers flushed");
    }
}
